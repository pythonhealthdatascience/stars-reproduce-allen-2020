---
title: "Day 3"
author: "Amy Heather"
date: "2024-05-23"
categories: [reproduce]
---

::: {.callout-note}

## Time elapsed

1h 9m today (total: 14.4%)

:::

## Work log

## 11.29-12.38 Reproduction

After some [untimed general revision of how random number generation works in Python](https://amyheather.github.io/programming_notes/python/seeds.html), I returned to trying to modify the code so it can reproduce results between runs.

A simple fix of adding a seed to some of the Uniform() functions that were still using random_seed=None meant that the simulation would now run exactly the same each time.

Run 1:

<img src="figure_1a.png" width="500" /> 

Run 2:

<img src="figure_1b.png" width="500" />


Then we needed a seperate seed with each run (else every run will produce identical results) This required changes to:
    * `single_run()` within `sim_replicate.py` so it can accept random number set as an argument, and then when it was called in `multiple_replications()`, to use the rep number as the starting seed
    * Scenario, changing it from a frozen dataclass to a class with a function that accepts a random number set, and then prompts generation of distributions from that

These changes were based on [this model](https://pythonhealthdatascience.github.io/stars-simpy-example-docs/content/02_model_code/04_model.html).

As can see, this has fixed it, as we have reproducible results between runs, and varying results within runs.

Run 1:

<img src="figure_2a.png" width="500" /> 

Run 2:

<img src="figure_2b.png" width="500" />

## Timings

```{python}
from datetime import datetime

# --------------------------------------------------------------
# Modify this section:

# Time in minutes that has been used prior to this day
used_to_date = 276

# List of times from today (as string tuples in list)
times = [
    ('11.29', '12.38')]
# --------------------------------------------------------------

FMT = '%H.%M'
total_min = 0
for t in times:
    # Convert to datetime object
    h0 = datetime.strptime(t[0], FMT)
    h1 = datetime.strptime(t[1], FMT)
    # Find difference in minutes and add to total
    total_min += (h1 - h0).total_seconds() / 60

# Time in hours and minutes
print(f'Time spent today: {int(total_min)}m - or {int(total_min)//60}h {int(total_min)%60}m')

# Total time used
total_used = total_min + used_to_date
print(f'Total used to date: {int(total_used)}m - or {int(total_used//60)}h {int(total_used%60)}m')

# Find time remaining
max = 40*60
remain_min = max - total_used
print(f'Time remaining: {int(remain_min)}m - or {int(remain_min//60)}h {int(remain_min%60)}m')

# Find proportion out of 40 hours
print(f'Used {round((total_min+used_to_date)/max*100,1)}% of 40 hours max')
```

## Suggested changes for protocol/template

âœ… = Made the change.

Protocol: 

* Increasing the emphasis on fiddling with the random number generators and seeds as likely being a large part of trying to reproduce the studies